###############################################################################
# Copyright (c) 2010, 2015 IBM Corporation and others.
#
# This program and the accompanying materials
# are made available under the terms of the Eclipse Public License 2.0
# which accompanies this distribution, and is available at
# https://www.eclipse.org/legal/epl-2.0/
#
# SPDX-License-Identifier: EPL-2.0
#
# Contributors:
#     IBM Corporation - initial API and implementation
###############################################################################

pluginName = e4 JDT code templates
providerName = Eclipse.org


#--- templates
templates.e4.contextType.name= e4
templates.e4.statements.contextType.name= e4 statements
templates.e4.members.contextType.name= e4 members

templates.java.resolvers.Field.name= Field
templates.java.resolvers.Field.description= <b>${<i>id</i>:field(type[,type]*)}</b><br>Evaluates to a field in the current scope that is a subtype of any of the given types. If no type is specified, any non-primitive field matches.<br><br><b>Example:</b><br><code>${counter:field(int)}</code>
templates.java.resolvers.Link.name= Linked Mode
templates.java.resolvers.Link.description= <b>${<i>id</i>:link([proposal[,proposal]*])}</b><br>Evaluates to <i>id</i> if the list of proposals is empty, evaluates to the first proposal otherwise. The evaluated value is put into linked mode. A proposal window shows all the given proposals.<br><br><b>Example1:</b><br><code>java.util.Collections.${kind:link(EMPTY_SET, EMPTY_LIST, 'EMPTY_MAP.entrySet()')}</code><br><br><b>Example2:</b><br><code>int ${integer:link}; ${integer}= 0;</code>
templates.java.resolvers.Imports.name= Import
templates.java.resolvers.Imports.description= <b>${:import([type[,type]*])}</b><br>Adds an import statement for each type that is not already imported. Does nothing if a conflicting import exists. Evaluates to nothing.<br><br><b>Example:</b><br><code>${:import(java.util.List, java.util.Collection)}</code>
templates.java.resolvers.ImportStatic.name= Import Static
templates.java.resolvers.ImportStatic.description= <b>${:importStatic([qualifiedName[,qualifiedName]*])}</b><br>Adds a static import statement for each qualified name that is not already imported. The <code>qualifiedName</code> is the fully qualified name of a static field or method, or it is the qualified name of a type plus a <code>.*</code> suffix, enclosed in single quotes <code>'\u0027</code>. Does nothing if a conflicting import exists. Evaluates to nothing.<br><br><b>Example:</b><br><code>${:importStatic(java.util.Collections.EMPTY_SET, 'java.lang.System.*')}</code>
templates.java.resolvers.Var.name= Variable
templates.java.resolvers.Var.description= <b>${<i>id</i>:var(type[,type]*)}</b><br>Evaluates to a field, local variable or parameter visible in the current scope that is a subtype of any of the given types. If no type is specified, any non-primitive variable matches.<br><br><b>Example:</b><br><code>${array:var('java.lang.Object[]')}</code>
templates.java.resolvers.LocalVar.name= Local Variable
templates.java.resolvers.LocalVar.description= <b>${<i>id</i>:localVar(type[,type]*)}</b><br>Evaluates to a local variable or parameter visible in the current scope that is a subtype of any of the given types. If no type is specified, any non-primitive local variable matches.<br><br><b>Example:</b><br><code>${iterable:localVar(java.lang.Iterable)}</code>
templates.java.resolvers.Name.name= New Name
templates.java.resolvers.Name.description= <b>${<i>id</i>:newName(reference)}</b><br>Evaluates to an non-conflicting name for a new local variable of the type specified by the reference. The reference may either be a Java type name or the name of another template variable. The generated name respects the code style settings.<br><br><b>Example:</b><br><code>${index:newName(int)}</code>
templates.java.resolvers.Type.name= New Type
templates.java.resolvers.Type.description= <b>${<i>id</i>:newType(fullyQualifiedType)}</b><br>Evaluates to a type name given the fully qualified Java type name. Evaluates to a simple type name and an import if no conflicting type exists. Evaluates to a fully qualified type name otherwise.<br><br><b>Example:</b><br><code>${type:newType(java.util.Iterator)}</code>
templates.java.resolvers.ElementType.name= Element Type
templates.java.resolvers.ElementType.description= <b>${<i>id</i>:elemType(variable)}</b><br>Evaluates to the element type of the referenced template variable. The reference should be the name of another template variable that resolves to an array or an instance of <code>java.lang.Iterable</code>.<br><br><b>Example:</b><br><code>${t:elemType(a)} elem = ${a:array};</code>
templates.java.resolvers.ArgumentType.name= Argument Type
templates.java.resolvers.ArgumentType.description= <b>${<i>id</i>:argType(variable, n)}</b><br> Evaluates to the <em>nth</em> type argument of the referenced template variable. The reference should be the name of another template variable. Resolves to <code>java.lang.Object</code> if the referenced variable cannot be found or is not a parameterized type.<br><br><b>Example:</b><br><code>${type:argType(vector, 0)} ${first:name(type)} = ${vector:var(java.util.Vector)}.get(0);</code>;
templates.java.resolvers.ExceptionVariableName.name= Exception Variable Name
templates.java.resolvers.ExceptionVariableName.description= Exception variable name in catch blocks
